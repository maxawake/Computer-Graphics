#ifndef _DATRAWLOADER_H_
#define _DATRAWLOADER_H_
#if (defined(_MSC_VER) && (_MSC_VER > 1000))
#pragma once
#endif /* (defined(_MSC_VER) && (_MSC_VER > 1000)) */
#if defined(_WIN32) && defined(_MANAGED)
#pragma managed(push, off)
#endif /* defined(_WIN32) && defined(_MANAGED) */

#ifdef _WIN32
#define OGL4COREPLUGIN_API __declspec(dllexport)
#define OGL4COREPLUGIN_CALL __cdecl
#else
#define OGL4COREPLUGIN_API
#define OGL4COREPLUGIN_CALL
#endif

#include "datRaw.h"
#include <GL/gl3w.h>

/**
* Adapter class to the datraw implementation from Thomas Klein.
*/
class OGL4COREPLUGIN_API DatRawLoader
{
private:
    /** Header struct */
    DatRawFileInfo header;
protected:
public:
    /**
    * ctor
    *
    * @param filename Path to the dat-File to be loaded.
    */
    DatRawLoader(const char *filename);

    /**
    * dtor
    */
    ~DatRawLoader(void);

    /**
    * Reads the i-th timestep into a texture. 
    * The texture will be generated by this method. 
    * Its identifier will be stored in the parameter "texture". 
    * Only 2D and 3D data is supported. 
    * Supported datatypes (signed and unsigned) are: BYTE, SHORT, INT, HALF_FLOAT and FLOAT.
    *
    * @param i Index of the timestep to be read.
    * @param texture Identifier of the texture the data is stored in.
    */
    void ReadTimestepToTexture(int i, unsigned int *texture);

    /**
    * Reads the i-th timestep into a buffer.
    * This method allocates memory by itself, which means the parameter "buf" should be NULL.
    * The size of the buffer can be retrieved by the method "GetBufferSize" and 
    * the datatype of the buffer elements by the method "GetDataFormat".
    *
    * @param i Index of the timestep to be read.
    * @param buf Buffer holding the data of the timestep.
    */
    void ReadTimestepToMemory(int i, void **buf);

    /**
    * Answers the overall number of timesteps within the datraw-file.
    *
    * @return The number of timesteps within the datraw-file.
    */
    int GetNumTimesteps(void);

    /**
    * Answers the number of dimensions of the data domain.
    *
    * @return The number of dimensions of the data domain.
    */
    int GetDimensions(void);

    /**
    * Answers the number of dimensions of a data element.
    *
    * @return The number of dimensions of a data element.
    */
    int GetNumComponents(void);

    /**
    * Answers the resolution of the data domain. 
    * It will be stored in the parameter "res". 
    * The number of elements of "res" can be retrieved by "GetDimensions".
    * This method allocates memory by itself, which means the parameter "res" should be NULL.
    *
    * Only valid for cartesian and rectilinear grids.
    *
    * @param res Points to an array containing the domain resolution.
    */
    void GetResolution(int *&res);

    /**
    * Answers the object-space distance between data elements in each dimension.
    * It will be stored in the parameter "dist".
    * The number of elements of "dist" can be retrieved by "GetDimensions".
    * This method allocates memory by itself, which means the parameter "dist" should be NULL.
    *
    * Only valid for cartesian and rectilinear grids.
    *
    * @param dist
    */
    void GetSliceDist(float *&dist);

    /**
    * Answers the data format as an index of the "DatRawDataFormat" enumeration.
    *
    * @return Index of the data format.
    */
    DatRawDataFormat GetDataFormat(void);

    /**
    * Answers the size of a buffer required to hold a timestep.
    *
    * @return Buffersize required for a timestep in bytes.
    */
    size_t GetBufferSize(void);
};

#if defined(_WIN32) && defined(_MANAGED)
#pragma managed(pop)
#endif /* defined(_WIN32) && defined(_MANAGED) */
#endif /* _DATRAWLOADER_H_ */
